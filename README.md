*This project has been created as part of the 42 curriculum by hwakatsu.*

“Description”
**get_next_line** は、ファイルディスクリプタから **1行ずつ** テキストを読み取る関数を実装するプロジェクトです。
読み込まれた行には、存在する場合 **改行文字 `\n` も含めて返す** 必要があります。

このプロジェクトでは以下の要素を深く理解することを目指します：

- ファイルディスクリプタと `read()` の動作
- 静的変数（または bonus の場合は複数 FD を扱うためのリスト）
- 動的メモリ管理（malloc / free）
- バッファリング手法
- 文字列操作と部分文字列の管理

本課題は、低レベルプログラミングの基礎を確実に固めることを目的としています。

“Instructions”
コンパイル方法、インストール方法、実行方法など、
プロジェクトを動かすために必要な情報をまとめること。

🔧 コンパイル
通常版：
cc -Wall -Wextra -Werror -D BUFFER_SIZE=42 get_next_line.c get_next_line_utils.c
ボーナス版：
cc -Wall -Wextra -Werror -D BUFFER_SIZE=42 get_next_line_bonus.c get_next_line_utils_bonus.c
▶️ 使用例

#include <fcntl.h>
#include <stdio.h>
#include "get_next_line.h"

int main(void)
{
    int fd = open("test.txt", O_RDONLY);
    char *line;

    while ((line = get_next_line(fd)) != NULL)
    {
        printf("%s", line);
        free(line);
    }
    close(fd);
    return (0);
}

“Resources”
テーマに関連する主要な文献・記事・チュートリアルなどの一覧

プロジェクトで AI をどのように使用したか を説明する文章

どのタスクで、どの部分で AI を用いたのか明記する

※ プロジェクトによっては追加のセクションが必要になる場合があります
（例：使用例、機能リスト、技術的選択の理由など）。

必要な追加項目がある場合は、このあと明示的に記載されます。
• 選択したアルゴリズムの詳細な説明と、その選択理由の記述

このプロジェクトで使用したアルゴリズムについて

どのように動作するか

なぜそのアルゴリズムを選んだのか（根拠・比較）

を詳しく説明する必要があります。


公式マニュアル

man 2 read

man 3 malloc

man 3 free

参考資料

get_next_line に関する 42 のフォーラム投稿

文字列管理に関する C 記事

バッファリングやファイル I/O のチュートリアル

🤖 このプロジェクトでの AI の使用について

AI（ChatGPT）は以下の目的で使用しました：

使用した内容

C 言語の仕様に関する質問

セグフォやメモリリークの原因解析

README の文章作成サポート

アルゴリズムの考え方の説明

使用していない内容

完成コードの生成

アルゴリズムの設計・主要ロジックの作成

代替としてのプログラミング行為

実装コードは自分で作成し、AI は学習補助・説明補助として活用しています。

🧠 アルゴリズムの説明と選択理由（Algorithm Explanation & Justification）
🔹 アルゴリズムの動作

静的変数（またはリスト）に未処理の読み残しを保持する

1回の read() では1行すべてが読み込まれない場合があるため、残りを保持します。

read() を使ってバッファに読み込み、content に追加する

改行 \n に遭遇するまでループ

EOF の場合は停止

1行だけを切り出して返す（extract_line）

content の先頭から改行までを取り出す

新しい文字列を malloc して返す

残りの部分を content として次回に持ち越す（remain_content）

読み取った1行を除いた部分を新しく保存

読み残しがない場合は free

メモリ管理の安全性

malloc 失敗時は必ず保持しているメモリを解放

次回呼び出しへ確実に影響が出ないようにする

🔎 なぜこのアルゴリズムを選んだのか？
✔ メリット

長い行でも安全に処理できる

read() の呼び出し回数を最小限に抑えられる

メモリリークのリスクが少ない構造

ボーナスでの複数 FD 管理との相性がよい

✔ 他の方法と比較
方法	採用しなかった理由
1バイトずつ read	非常に遅い（read のコストが高い）
バッファを固定サイズのまま保持	長い行を扱えない
毎回 realloc	実装が複雑になりやすく、エラー処理が困難

最も実用的で安全性が高いのが現在の方法です。

🧪 テスト

42 のテスター：

francinette --strict
